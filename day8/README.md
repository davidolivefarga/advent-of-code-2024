# Day 8: Resonant Collinearity

You can find the puzzles [here](https://adventofcode.com/2024/day/8).

## âœðŸ¼ Input

A grid representing a map, that has two types of tiles:

-   Empty tiles, represented by a `.`.
-   Antenna tiles, represented by a single lowercase letter, uppercase letter, or digit.

```js
const input = [
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", "0", ".", ".", "."],
    [".", ".", ".", ".", ".", "0", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", "0", ".", ".", ".", "."],
    [".", ".", ".", ".", "0", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", "A", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", "A", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", "A", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
    [".", ".", ".", ".", ".", ".", ".", ".", ".", ".", ".", "."],
];
```

## ðŸ§© First puzzle

### Objective

Each antenna has its own frequency, represented by its tile type (`A` and `a` have different frequencies).

An antinode occurs at any point that is perfectly in line with two antennas of the same frequency, but only when one of the antennas is twice as far. This means that for any pair of antennas with the same frequency, there are two antinodes, one on either side of them. It is possible for antinodes to overlap, and to occur at the same position where there's already an antenna.

Find the amount of unique locations within the bounds of the map that contain an antinode.

### Solution

Puzzles are getting harder!

My solution consists on the following steps:

1. Scan the map to get the positions of all antennas by frequency.
2. Initialize a set to keep track of the antinode positions, to avoid counting the same position twice.
3. For each frequency, get all possible combinations of pairs of positions and:
    - Calculate the antinodes generated by this pair of positions.
    - Filter out the antinodes that are outside the map bounds.
    - Add the remaining antinodes to a set (this helps us avoid counting the same position twice).
4. Return the set size.

The trickiest part is to calculate the nodes of a given pair of positions, but this is not difficult if you treat them as vectors. Suppose that one antenna is at position `p1 = (x1, y1)` and the other is at position `p2 = (x2, y2)`. If you consider the vector `v = p1 - p2 = (x1 - x2, y1 - y2)`, it represents what is needed to carry `p2` to `p1`, because `p1 = p2 + v`. This means that `a1 = p1 + v = p2 + 2 * v` will be twice as far from `p2` than from `p1`, so we have one antinode. Similarly, since `p2 = p1 - v`, `a2 = p2 - v = p1 - 2 * v` will be twice as far from `p1` than from `p2`, so we have the other antinode.

**Note:** in theory, given two positions, we would actually have 4 antinodes. Besides `a1 = p1 + v` and `a2 = p2 - v`, we also have `a3 = p2 + 1/3 * v` and `a4 = p2 + 2/3 * v`, as these also satisfy the condition of "being perfectly in line with two antennas of the same frequency but with one of the antennas twice as far as the other". It's true that these interior antinodes won't always fit perfectly in the grid, in the sense that that their coordinates might not be integers... But even then, the input is guaranteed to not have interior antinodes, so no need to take them into account for the solution.

```js
const EMPTY_TILE = ".";

function solve(map) {
    const antennaPositions = getAntennaPositions(map);
    const antinodePositions = new Set();

    Object.values(antennaPositions).forEach((positions) => {
        for (let i = 0; i < positions.length; i++) {
            for (let j = i + 1; j < positions.length; j++) {
                const antinodes = getAntinodes(map, positions[i], positions[j]);

                antinodes.forEach((antinode) => {
                    antinodePositions.add(antinode.toString());
                });
            }
        }
    });

    return antinodePositions.size;
}

function getAntennaPositions(map) {
    const m = map.length;
    const n = map[0].length;

    const antennaPositions = {};

    for (let i = 0; i < m; i++) {
        for (let j = 0; j < n; j++) {
            if (map[i][j] !== EMPTY_TILE) {
                if (!antennaPositions[map[i][j]]) {
                    antennaPositions[map[i][j]] = [[i, j]];
                } else {
                    antennaPositions[map[i][j]].push([i, j]);
                }
            }
        }
    }

    return antennaPositions;
}

function getAntinodes(map, pos1, pos2) {
    const v = [pos1[0] - pos2[0], pos1[1] - pos2[1]];

    const antinodes = [
        [pos1[0] + v[0], pos1[1] + v[1]],
        [pos2[0] - v[0], pos2[1] - v[1]],
    ];

    return antinodes.filter((antinode) => isWithinMap(map, antinode));
}

function isWithinMap(map, pos) {
    const m = map.length;
    const n = map[0].length;

    return pos[0] >= 0 && pos[0] < m && pos[1] >= 0 && pos[1] < n;
}
```

## ðŸ§© Second puzzle

### Objective

Same objective as before, but this time there's a twist! It turns out that an antinode occurs at any grid position exactly in line with at least two antennas of the same frequency, regardless of distance. This means that some of the new antinodes will occur at the position of each antenna (unless that antenna is the only one of its frequency).

### Solution

Same idea, we just need to change the way we calculate the antinodes.

The first thought could be to calculate `v = p1 - p2` as before and then generate the following antinodes:

-   `p1`, `p1 + v`, `p1 + 2 * v`, `p1 + 3 * v` and so on until we reach the bounds of the map
-   `p2`, `p2 - v`, `p2 - 2 * v`, `p2 - 3 * v` and so on until we reach the bounds of the map

While these antinodes are all valid, we're missing some. For example, consider `p1 = (2, 2)` and `p2 = (4, 4)`. Using the above technique, we would miss antinodes like `(1, 1)`, `(3, 3)` or `(5, 5)`. This is because in this case we have `v = (2, 2)`, and this vector can be "normalized" in the sense that it can be made smaller while still having integers as its coordinates: `nv = (1, 1)`. To calculate `nv` in general, we need to compute GCD (greatest common divisor) of the components of `v` and divide them of `v` by this value. This will ensure that we end up with the smallest version of `v` that has integers as its coordinates.

This means that our problem now is to calculate the GCD of two integers, and for that we can use the [Euclidean algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm).

Once we calculate `nv`, we can obtain all antinodes as follows:

-   `p1`
-   `p1 + nv`, `p1 + 2 * nv`, `p1 + 3 * nv` and so on until we reach the bounds of the map
-   `p1 - nv`, `p1 - 2 * nv`, `p1 - 3 * nv` and so on until we reach the bounds of the map

**Note:** I learned, after submitting the solution, that the input is carefully crafted in such a way that if `v = (x, y)`, then `gcd(x, y) = 1`... So again, we won't have interior antinodes and we could simply the solution by skipping the whole normalization part. However, given that I took the effort to do it, I decided to leave it there, to make the solution more generic.

```js
const EMPTY_TILE = ".";

function solve(map) {
    // Same as before
}

function getAntennaPositions(map) {
    // Same as before
}

function getAntinodes(map, pos1, pos2) {
    const v = [pos1[0] - pos2[0], pos1[1] - pos2[1]];
    const vGcd = gcd(v[0], v[1]);
    const vNormalized = [v[0] / vGcd, v[1] / vGcd];

    let antinode = pos1;

    const antinodes = [antinode];

    antinode = [pos1[0] + vNormalized[0], pos1[1] + vNormalized[1]];

    while (isWithinMap(map, antinode)) {
        antinodes.push(antinode);

        antinode = [antinode[0] + vNormalized[0], antinode[1] + vNormalized[1]];
    }

    antinode = [pos1[0] - vNormalized[0], pos1[1] - vNormalized[1]];

    while (isWithinMap(map, antinode)) {
        antinodes.push(antinode);

        antinode = [antinode[0] - vNormalized[0], antinode[1] - vNormalized[1]];
    }

    return antinodes;
}

function gcd(a, b) {
    if (!b) {
        return a;
    }

    return gcd(b, a % b);
}

function isWithinMap(map, pos) {
    // Same as before
}
```
